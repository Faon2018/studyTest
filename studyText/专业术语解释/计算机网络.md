> # 计算机网络

OSI 七层协定 (Open System Interconnection)

![osi_tcpip](..\images\osi_layer_to_layer.gif)

每个一阶层只认识对方的同一阶层数据。 

透过应用程序将数据放入第七层的包裹，再将第七层的包裹放到第六层的包裹内， 依序一直放到第一层的最大的包裹内，然后传送出去给接收端。接收端的主机就得由第一个包裹开始，依序将每个包裹拆开， 然后一个一个交给对应负责的阶层来视察。

在七层协议中，每层都会有自己独特的表头数据 (header)，告知对方这里面的信息是什么， 而真正的数据就附在后头

OSI 七层协议数据的传递方式：

![osi_tcpip](..\images\osi_packet.gif)

上图中仔细看每个数据报的部分，上层的包裹是放入下层的数据中，而数据前面则是这个数据的表头。其中比较特殊的是第二层， 因为第二层 (数据链结层) 主要是位于软件封包 (packet) 以及硬件讯框 (frame) 中间的一个阶层， 他必须要将软件包装的包裹放入到硬件能够处理的包裹中，因此这个阶层又分为两个子层在处理相对应的数据。 因为比较特殊，所以第二层的数据格式比较不一样，尾端还出现一个检查码。

每一个阶层所负责的任务：

| 分层                               | 负责内容                                                     |
| ---------------------------------- | ------------------------------------------------------------ |
| Layer 1 物理层 Physical Layer      | 由于网络媒体只能传送 0 与 1 这种位串，因此物理层必须定义所使用的媒体设备之电压与讯号等， 同时还必须了解数据讯框转成位串的编码方式，最后连接实体媒体并传送/接收位串。 |
| Layer 2 数据链结层 Data-Link Layer | 这一层是比较特殊的一个阶层，因为底下是实体的定义，而上层则是软件封装的定义。因此第二层又分两个子层在进行数据的转换动作。 在偏硬件媒体部分，主要负责的是 MAC (Media Access Control) ，我们称这个数据报裹为 MAC 讯框 (frame)， MAC 是网络媒体所能处理的主要数据报裹，这也是最终被物理层编码成位串的数据。MAC 必须要经由通讯协议来取得媒体的使用权， 目前最常使用的则是 IEEE 802.3 的以太网络协议。详细的 MAC 与以太网络请参考下节说明。  至于偏向软件的部分则是由逻辑链接层 (logical link control, LLC) 所控制，主要在多任务处理来自上层的封包数据 (packet) 并转成 MAC 的格式， 负责的工作包括讯息交换、流量控制、失误问题的处理等等。 |
| Layer 3 网络层 Network Layer       | 这一层是我们最感兴趣的啰，因为我们提及的 IP (Internet Protocol) 就是在这一层定义的。 同时也定义出计算机之间的联机建立、终止与维持等，数据封包的传输路径选择等等，因此这个层级当中最重要的除了 IP 之外，就是封包能否到达目的地的路由 (route) 概念了！ |
| Layer 4 传送层 Transport Layer     | 这一个分层定义了发送端与接收端的联机技术(如 TCP, UDP 技术)， 同时包括该技术的封包格式，数据封包的传送、流程的控制、传输过程的侦测检查与复原重新传送等等， 以确保各个数据封包可以正确无误的到达目的端。 |
| Layer 5 会谈层 Session Layer       | 在这个层级当中主要定义了两个地址之间的联机信道之连接与挂断，此外，亦可建立应用程序之对谈、 提供其他加强型服务如网络管理、签到签退、对谈之控制等等。如果说传送层是在判断资料封包是否可以正确的到达目标， 那么会谈层则是在确定网络服务建立联机的确认。 |
| Layer 6 表现层 Presentation Layer  | 我们在应用程序上面所制作出来的数据格式不一定符合网络传输的标准编码格式的！ 所以，在这个层级当中，主要的动作就是：将来自本地端应用程序的数据格式转换(或者是重新编码)成为网络的标准格式， 然后再交给底下传送层等的协议来进行处理。所以，在这个层级上面主要定义的是网络服务(或程序)之间的数据格式的转换， 包括数据的加解密也是在这个分层上面处理。 |
| Layer 7 应用层 Application Layer   | 应用层本身并不属于应用程序所有，而是在定义应用程序如何进入此层的沟通接口，以将数据接收或传送给应用程序，最终展示给用户。 |

OSI 与 TCP/IP 协议之相关性：

![osi_tcpip](..\images\osi_tcpip.gif)

从上图中，我们可以发现 TCP/IP 将应用、表现、会谈三层整合成一个应用层，在应用层上面可以实作的程序协议有 HTTP, SMTP, DNS 等等。 传送层则没有变，不过依据传送的可靠性又将封包格式分为连接导向的 TCP 及非连接导向的 UDP 封包格式。网络层也没有变，主要内容是提供了 IP 封包，并可选择最佳路由来到达目标 IP 地址。数据链结层与物理层则整合成为一个链结层，包括定义硬件讯号、 讯框转位串的编码等等，因此主要与硬件 (不论是区网还是广域网) 有关。

连接浏览器入口网站的步骤：

1. 应用程序阶段：妳打开浏览器，在浏览器上面输入网址列，按下 [Enter]。此时网址列与相关数据会被浏览器包成一个数据， 并向下传给 TCP/IP 的应用层；

2. 应用层：由应用层提供的 HTTP 通讯协议，将来自浏览器的数据报起来，并给予一个应用层表头，再向传送层丢去；

3. 传送层：由于 HTTP 为可靠联机，因此将该数据丢入 TCP 封包内，并给予一个 TCP 封包的表头，向网络层丢去；

4. 网络层：将 TCP 包裹包进 IP 封包内，再给予一个 IP 表头 (主要就是来源与目标的 IP )，向链结层丢去；

5. 链结层：如果使用以太网络时，此时 IP 会依据 CSMA/CD 的标准，包裹到 MAC 讯框中，并给予 MAC 表头，再转成位串后， 利用传输媒体传送到远程主机上。

   等到 浏览器 收到你的包裹后，在依据相反方向拆解开来，然后交给对应的层级进行分析，最后就让 浏览器 的 WWW 服务器软件得到你所想要的数据，该服务器软件再根据你的要求，取得正确的资料后，又依循上述的流程，一层一层的包装起来， 最后传送到你的手上

> ## **以太网络的传输协议：CSMA/CD**

以太网络的重心就是以太网络卡,每张以太网络卡出厂时，就会赋予一个独一无二的卡号，那就是所谓的 MAC (Media Access Control),以太网络的网卡之间数据传输依据IEEE 802.3 的标准 CSMA/CD (Carrier Sense Multiple Access with Collision Detection)。

![](..\images\csmacd.gif)



中心点为集线器， 各个主机都是联机到集线器，然后透过集线器的功能向所有主机发起联机的。集线器是一种网络共享媒体，网络共享媒体在单一时间点内， 仅能被一部主机所使用。

 CSMA/CD 搭配上述的环境，它的传输情况需要有以下的流程：

1. 监听媒体使用情况 (Carrier Sense)：A 主机要发送网络封包前，需要先对网络媒体进行监听，确认没有人在使用后， 才能够发送出讯框；
2. 多点传输 (Multiple Access)：A 主机所送出的数据会被集线器复制一份，然后传送给所有连接到此集线器的主机！ 也就是说， A 所送出的数据， B, C, D 三部计算机都能够接收的到！但由于目标是 D 主机，因此 B 与 C 会将此讯框数据丢弃，而 D 则会抓下来处理；
3. 碰撞侦测 (Collision Detection)：该讯框数据附有检测能力，若其他主机例如 B 计算机也刚好在同时间发送讯框数据时， 那么 A 与 B 送出的数据碰撞在一块 (出车祸) ，此时这些讯框就是损毁，那么 A 与 B 就会各自随机等待一个时间， 然后重新透过第一步再传送一次该讯框数据。

> ## MAC的封装格式

上面提到的 CSMA/CD 传送出去的讯框数据，其实就是 MAC ！MAC 其实就是我们上面一直讲到的讯框 (frame) ！ 只是这个讯框上面有两个很重要的数据，就是目标与来源的网卡卡号，因此我们又简称网卡卡号为 MAC 而已。 简单的说，你可以把 MAC 想成是一个在网络线上面传递的包裹，而这个包裹是整个网络硬件上面传送数据的最小单位了。 也就是说，网络线可想成是一条『一次仅可通过一个人』的独木桥， 而 MAC 就是在这个独木桥上面动的人啦！接下来，来看一看 MAC 这个讯框的内容吧！

![](..\images\mac.png)

​							以太网络的 MAC 讯框

目的地址与来源地址指的就是网卡卡号 (hardware address, 硬件地址);硬件地址最小由 00:00:00:00:00:00 到 FF:FF:FF:FF:FF:FF (16 进位法)， 这 6 bytes 当中，前 3bytes 为厂商的代码，后 3bytes 则是该厂商自行设定的装置码了。

讯框内的数据内容最大可达 1500bytes 这我们现在知道了，那为何要规范最小数据为 46bytes 呢？这是由于 CSMA/CD 机制所算出来的！ 在这个机制上面可算出若要侦测碰撞，则讯框总数据量最小得要有 64bytes 。

标准以太网络讯框所能传送的数据量最大可以到达 1500 bytes ， 这个数值就被我们称为 MTU (Maximum Transmission Unit, 最大传输单位)。

> ## 集线器、交换器

集线器 (hub) 这个网络共享媒体就可能会发生碰撞的情况， 这是因为 CSMA/CD 的缘故。那有没有办法避免这种莫名其妙的封包碰撞情况呢？有的，那就使用非共享媒体的交换器。

交换器 (switch) 等级非常多，我们这里仅探讨支持 OSI 第二层的交换器。交换器与集线器最大的差异，在于交换器内有一个特别的内存， 这个内存可以记录每个 switch port 与其连接的 PC 的 MAC 地址，所以，当来自 switch 两端的 PC 要互传数据时，每个讯框将直接透过交换器的内存数据而传送到目标主机上！ 所以 switch 不是共享媒体，且 switch 的每个埠口 (port) 都具有独立的带宽喔！

最常见的网络硬件接口为以太网络，包括网络线、网络卡、Hub/Switch 等等。而以太网络上面的传输使用网络卡卡号为基准的 MAC 讯框，配合 CSMA/CD 的标准来传送讯框，这就是硬件部分。

> ## IP封包的封装

 IP 封包可以达到 65535 bytes 这么大，在比 MAC 大的情况下，我们的操作系统会对 IP 进行拆解的动作。至于 IP 封装的表头数据绘制如下：

![image-20210115150217726](..\images\image-20210115150217726.png)

​																				IP 封包的表头资料

在上面的图示中有个地方要注意，那就是『每一行所占用的位数为 32 bits』， 各个表头的内容分别介绍如下：

- Version(版本)
  宣告这个 IP 封包的版本，例如目前惯用的还是 IPv4 这个版本就在这里宣告。

  

- IHL(Internet Header Length, IP表头的长度)
  告知这个 IP 封包的表头长度，使用的单位应该是字组 (word) ，一个字组为 4bytes 大小喔。

  

- Type of Service(服务类型)
  这个项目的内容为『PPPDTRUU』，表示这个 IP 封包的服务类型，主要分为：
  PPP：表示此 IP 封包的优先度，目前很少使用；
  D：若为 0 表示一般延迟(delay)，若为 1 表示为低延迟；
  T：若为 0 表示为一般传输量 (throughput)，若为 1 表示为高传输量；
  R：若为 0 表示为一般可靠度(reliability)，若为 1 表示高可靠度。
  UU：保留尚未被使用。
  举例来说，gigabit 以太网络的种种相关规格可以让这个 IP 封包加速且降低延迟，某些特殊的标志就是在这里说明的。

  

- Total Length(总长度)
  指这个 IP 封包的总容量，包括表头与内容 (Data) 部分。最大可达 65535 bytes。

  

- Identification(辨别码)
  我们前面提到 IP 袋子必须要放在 MAC 袋子当中。不过，如果 IP 袋子太大的话，就得先要将 IP 再重组成较小的袋子然后再放到 MAC 当中。而当 IP 被重组时，每个来自同一个 IP 的小袋子就得要有个标识符以告知接收端这些小袋子其实是来自同一个 IP 封包才行。 也就是说，假如 IP 封包其实是 65536 那么大 (前一个 Total Length 有规定)， 那么这个 IP 就得要再被分成更小的 IP 分段后才能塞进 MAC 讯框中。那么每个小 IP 分段是否来自同一个 IP 资料，呵呵！那就是这个标识符的功用啦！

  

- Flags(特殊旗标)
  这个地方的内容为『0DM』，其意义为：
  D：若为 0 表示可以分段，若为 1 表示不可分段
  M：若为 0 表示此 IP 为最后分段，若为 1 表示非最后分段。

  

- Fragment Offset(分段偏移)
  表示目前这个 IP 分段在原始的 IP 封包中所占的位置。就有点像是序号啦，有这个序号才能将所有的小 IP 分段组合成为原本的 IP 封包大小嘛！透过 Total Length, Identification, Flags 以及这个 Fragment Offset 就能够将小 IP 分段在收受端组合起来啰！

  

- **Time To Live(TTL, 存活时间)**
  表示这个 IP 封包的存活时间，范围为 0-255。当这个 IP 封包通过一个路由器时， TTL 就会减一，当 TTL 为 0 时，这个封包将会被直接丢弃。说实在的，要让 IP 封包通过 255 个路由器，还挺难的～ ^_^

  

- Protocol Number(协定代码)

  来自传输层与网络层本身的其他数据都是放置在 IP 封包当中的，我们可以在 IP 表头记载这个 IP 封包内的资料是啥， 在这个字段就是记载每种数据封包的内容啦！在这个字段记载的代码与相关的封包协议名称如下所示：

  

  | IP 内的号码 | 封包协议名称(全名)                        |
  | ----------- | ----------------------------------------- |
  | 1           | ICMP (Internet Control Message Protocol)  |
  | 2           | IGMP (Internet Group Management Protocol) |
  | 3           | GGP (Gateway-to-Gateway Protocol)         |
  | 4           | IP (IP in IP encapsulation)               |
  | 6           | TCP (Transmission Control Protocol)       |
  | 8           | EGP (Exterior Gateway Protocol)           |
  | 17          | UDP (User Datagram Protocol)              |

  当然啦，我们比较常见到的还是那个 TCP, UDP, ICMP 说！

- Header Checksum(表头检查码)
  用来检查这个 IP 表头的错误检验之用。

  

- **Source Address**
  还用讲吗？当然是来源的 IP 地址，从这里我们也知道 IP 是 32 位喔！

  

- **Destination Address**
  有来源还需要有目标才能传送，这里就是目标的 IP 地址。

  

- Options (其他参数)
  这个是额外的功能，提供包括安全处理机制、路由纪录、时间戳、严格与宽松之来源路由等。

  

- Padding(补齐项目)
  由于 Options 的内容不一定有多大，但是我们知道 IP 每个数据都必须要是 32 bits，所以，若 Options 的数据不足 32 bits 时，则由 padding 主动补齐。

> ## IP地址

IP地址（Internet Protocol Address）是指[互联网](https://baike.baidu.com/item/互联网/199186)协议地址，又译为网际协议地址。

IP地址是[IP协议](https://baike.baidu.com/item/IP协议/131947)提供的一种统一的[地址格式](https://baike.baidu.com/item/地址格式/53569124)，它为互联网上的每一个网络和每一台[主机](https://baike.baidu.com/item/主机/455151)分配一个[逻辑地址](https://baike.baidu.com/item/逻辑地址/3283849)，以此来屏蔽[物理地址](https://baike.baidu.com/item/物理地址/2901583)的差异。

> ## IP协议

IP协议是为[计算机网络](https://baike.baidu.com/item/计算机网络)相互连接进行通信而设计的协议。

> ## IP地址编址方式

+ ### A类IP地址

  一个A类IP地址是指， 在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。网络地址的最高位必须是“0”。

  A类IP地址 地址范围1.0.0.1到126.255.255.254 （二进制表示为：``00000001`` 00000000 00000000 00000001 - ``01111111`` 11111111 11111111 11111110）。最后一个是广播地址。

+ ### B类IP地址

  一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码。网络地址的最高位必须是“10”。

  B类IP地址地址范围128.0.0.1-191.255.255.254 （二进制表示为：10000000 00000000 00000000 00000001----10111111 11111111 11111111 11111110）。 最后一个是广播地址。B类IP地址的子网掩码为255.255.0.

+ ### C类IP地址

  一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。网络地址的最高位必须是“110”。

  C类IP地址范围192.0.0.1-223.255.255.254 （二进制表示为: 11000000 00000000 00000000 00000001 - 11011111 11111111 11111111 11111110）。C类IP地址的子网掩码为255.255.255.0

+ ### D类IP地址

  D类IP地址在历史上被叫做[多播地址](https://baike.baidu.com/item/多播地址)(multicast address)，即[组播地址](https://baike.baidu.com/item/组播地址)。在[以太网](https://baike.baidu.com/item/以太网)中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是“1110”，范围从224.0.0.0到239.255.255.255。

+ ###  E类IP地址

  Class E 则是保留没有使用的网段。240.xx.xx.xx ~ 255.xx.xx.xx

> ## 特殊的网址

1. 每一个字节都为0的地址（“0.0.0.0”）对应于当前[主机](https://baike.baidu.com/item/主机)；
2. IP地址中的每一个字节都为1的IP地址（“255．255．255．255”）是当前子网的[广播地址](https://baike.baidu.com/item/广播地址)；
3. IP地址中凡是以“11110”开头的[E类IP地址](https://baike.baidu.com/item/E类IP地址)都保留用于将来和实验使用。
4. IP地址中不能以十进制“127”作为开头，该类地址中数字127．0．0．1到127．255．255．255用于回路测试，如：[127.0.0.1](https://baike.baidu.com/item/127.0.0.1)可以代表本机IP地址，用“http://127.0.0.1”就可以测试本机中配置的Web服务器。
5. 网络ID的第一个6位组也不能全置为“0”，全“0”表示本地网络



> ##  **IP 的种类与取得方式**



在 IPv4 里面就只有两种 IP 的类别，分别是：

- **Public IP** : 公共 IP ，经由 INTERNIC 所统一规划的 IP，有这种 IP 才可以连上 Internet ；
- **Private IP** : 私有 IP 或保留 IP，不能直接连上 Internet 的 IP ， 主要用于局域网络内的主机联机规划。

早在 IPv4 规划的时候就担心 IP 会有不足的情况，而且为了应付某些企业内部的网络设定，于是就有了私有 IP (Private IP) 的产生了。私有 IP 也分别在 A, B, C 三个 Class 当中各保留一段作为私有 IP 网段，那就是：

- Class A：10.0.0.0  - 10.255.255.255
- Class B：172.16.0.0 - 172.31.255.255
- Class C：192.168.0.0 - 192.168.255.255

私有IP 限制：

- 私有 IP 的路由信息不能对外散播 (只能存在内部网络)；
- 使用私有 IP 作为来源或目的地址的封包，不能透过 Internet 来转送 (不然网络会混乱)；
- 关于私有 IP 的参考纪录(如 DNS)，只能限于内部网络使用 (一样的原理啦)



> ### 特殊的 loopback IP 网段

一个奇怪的 Class A 的网域，那就是 lo 这个奇怪的网域 (注意：是小写的 o 而不是零喔)！这个 lo 的网络是当初被用来作为测试操作系统内部循环所用的一个网域，同时也能够提供给系统内部原本就需要使用网络接口的服务 (daemon) 所使用。

简单的说，如果你没有安装网络卡在的机器上面， 但是你又希望可以测试一下在你的机器上面设定的服务器环境到底可不可以顺利运作，这个时候怎么办，就是利用这个所谓的内部循环网络啦！这个网段在 127.0.0.0/8 这个 Class A，而且默认的主机 (localhost) 的 IP 是 127.0.0.1 呦！所以啰，当你启动了你的 WWW 服务器，然后在你的主机的 X-Window 上面执行 http://localhost 就可以直接看到你的主页啰！而且不需要安装网络卡呢！测试很方便吧！

> ## 子网掩码**(Netmask、**Subnet mask**)**

子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。 

在同物理网段的主机如果设定相同的网域 IP 范围 (不可重复)，则这些主机都可以透过 CSMA/CD 的功能直接在区网内用广播进行网络的联机，亦即可以直接网卡对网卡传递数据 (透过 MAC 讯框)；

IP地址的子网掩码设置不是任意的。如果将子网掩码设置过大，也就是说子网范围扩大，那么，根据子网寻径规则，很可能发往和本地机不在同一子网内的目的机的数据，会因为错误的判断而认为目的机是在同一子网内，那么，数据包将在本子网内循环，直到超时并抛弃，使数据不能正确到达目的机，导致网络传输错误；如果将子网掩码设置得过小，那么就会将本来属于同一子网内的机器之间的通信当做是跨子网传输，数据包都交给缺省网关处理，这样势必增加缺省网关的负担，造成网络效率下降。因此，子网掩码应该根据网络的规模进行设置。

写法：

192.168.0.0/24 或 192.168.0.0/255.255.255.0

> ## **IP 与 MAC：链结层的 ARP 与 RARP 协定**

 Internet 上面最重要的就是那个 IP 了，也会计算所谓的局域网络与路由。 但是，事实上用在传递数据的明明就是以太网络啊！以太网络主要是用网卡卡号 (MAC) 的嘛！这就有问题啦！那这两者 (IP 与 MAC) 势必有一个关连性存在吧？没错！那就是我们要谈到的 ARP (Address Resolution Protocol, 网络地址解析) 协议，以及 RARP (Revers ARP, 反向网络地址解析)

当我们想要了解某个 IP 其实是设定于某张以太网络卡上头时，我们的主机会对整个区网发送出 ARP 封包， 对方收到 ARP 封包后就会回传他的 MAC 给我们，我们的主机就会知道对方所在的网卡，那接下来就能够开始传递数据啰。 如果每次要传送都得要重新来一遍这个 ARP 协定那不是很烦？因此，当使用 ARP 协议取得目标 IP 与他网卡卡号后， 就会将该笔记录写入我们主机的 ARP table 中 (内存内的数据) 记录 20 分钟 。

```shell
[root@www ~]# arp -[nd] hostname 
[root@www ~]# arp -s hostname(IP) Hardware_address 
选项与参数： 
-n ：将主机名以 IP 的型态显示 
-d ：将 hostname 的 hardware_address 由 ARP table 当中删除掉 
-s ：设定某个 IP 或 hostname 的 MAC 到 ARP table 当中  
范例一：列出目前主机上面记载的 IP/MAC 对应的 ARP 表格 
[root@www ~]# arp -n 
Address            HWtype  HWaddress           Flags Mask    Iface 
192.168.1.100      ether   00:01:03:01:02:03      C          eth0 
192.168.1.240      ether   00:01:03:01:DE:0A      C          eth0 
192.168.1.254      ether   00:01:03:55:74:AB      C          eth0 
范例二：将 192.168.1.100 那部主机的网卡卡号直接写入 ARP 表格中 
[root@www ~]# arp -s 192.168.1.100  01:00:2D:23:A1:0E # 这个指令的目的在建立静态 ARP 
```

> ##  **ICMP 协定**

ICMP 的全名是『 Internet Control Message Protocol, 因特网讯息控制协议 』。 基本上，ICMP 是一个错误侦测与回报的机制，最大的功能就是可以确保我们网络的联机状态与联机的正确性！ ICMP 也是网络层的重要封包之一，不过，这个封包并非独立存在，而是纳入到 IP 的封包中！也就是说， ICMP 同样是透过 IP 封包来进行数据传送的啦！因为在 Internet 上面有传输能力的就是 IP 封包啊！ ICMP 有相当多的类别可以侦测与回报，底下是比较常见的几个 ICMP 的类别 (Type)：

| 类别代号 | 类别名称与意义                                               |
| -------- | ------------------------------------------------------------ |
| 0        | Echo Reply (代表一个响应信息)                                |
| 3        | Destination Unreachable (表示目的地不可到达)                 |
| 4        | Source Quench (当 router 的负载过高时，此类别码可用来让发送端停止发送讯息) |
| 5        | Redirect (用来重新导向路由路径的信息)                        |
| 8        | Echo Request (请求响应消息)                                  |
| 11       | Time Exceeded for a Datagram (当数据封包在某些路由传送的现象中造成逾时状态，此类别码可告知来源该封包已被忽略的讯息) |
| 12       | Parameter Problem on a Datagram (当一个 ICMP 封包重复之前的错误时，会回复来源主机关于参数错误的讯息) |
| 13       | Timestamp Request (要求对方送出时间讯息，用以计算路由时间的差异，以满足同步性协议的要求) |
| 14       | Timestamp Reply (此讯息纯粹是响应 Timestamp Request 用的)    |
| 15       | Information Request (在 RARP 协议应用之前，此讯息是用来在开机时取得网络信息) |
| 16       | Information Reply (用以响应 Infromation Request 讯息)        |
| 17       | Address Mask Request (这讯息是用来查询子网 mask 设定信息)    |
| 18       | Address Mask Reply (响应子网 mask 查询讯息的)                |

那么我们是如何利用 ICMP 来检验网络的状态呢？最简单的指令就是 ping 与 traceroute 了， 这两个指令可以透过 ICMP 封包的辅助来确认与回报网络主机的状态。

> ## **可靠联机的 TCP 协议**

在网络层的 IP 之上则是传送层，而传送层的数据打包成什么？ 最常见的就是 TCP 封包了。这个 TCP 封包数据必须要能够放到 IP 的数据袋当中才行喔！ 所以将 MAC, IP 与 TCP 的封包数据这样看：

![](..\images\packet_total.png)

TCP封包的表头：

![image-20210115164953071](..\images\image-20210115164953071.png)

​																			TCP 封包的表头资料

- **Source Port & Destination Port (来源端口 & 目标端口)**
   IP 封包的传送主要是藉由 IP 地址连接两端， 但是到底这个联机的通道是连接到哪里去呢？没错！就是连接到 port 上头啦！ 举例来说，网站有开放 WWW 服务器，这表示网站的主机必须要启动一个可以让 client 端连接的端口，这个端口就是 port (中文翻译成为端口)。同样的，客户端想要连接到网站时，就必须要在 client 主机上面启动一个 port ，这样这两个主机才能够利用这条『通道』来传递封包数据喔！这个目标与来源 port 的纪录，可以说是 TCP 封包上最重要的参数了！

- **Sequence Number (封包序号)**
  由于 TCP 封包必须要带入 IP 封包当中，所以如果 TCP 数据太大时(大于 IP 封包的容许程度)， 就得要进行分段。这个 Sequence Number 就是记录每个封包的序号，可以让收受端重新将 TCP 的数据组合起来。

- **Acknowledge Number (回应序号)**
  为了确认主机端确实有收到我们 client 端所送出的封包数据，我们 client 端当然希望能够收到主机方面的响应，那就是这个 Acknowledge Number 的用途了。 当 client 端收到这个确认码时，就能够确定之前传递的封包已经被正确的收下了。

- Data Offset (资料补偿)
  在上图 倒数第二行有个 Options 字段！那个 Options 的字段长度是非固定的，而为了要确认整个 TCP 封包的大小，就需要这个标志来说明整个封包区段的起始位置。

- Reserved (保留)
  未使用的保留字段。

- Code (Control Flag, 控制标志码)

  当我们在进行网络联机的时候，必须要说明这个联机的状态，好让接收端了解这个封包的主要动作。 这可是一个非常重要的句柄喔！这个字段共有 6 个 bits ，分别代表 6 个句柄，若为 1 则为启动。分别说明如下：

  - URG(Urgent)：若为 1 则代表该封包为紧急封包， 接收端应该要紧急处理，且图 2.4-1 中的 Urgent Pointer 字段也会被启用。
  - ACK(Acknowledge)：若为 1 代表这个封包为响应封包， 则与上面提到的 Acknowledge Number 有关。
  - PSH(Push function)：若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无须等待缓冲区满了才送。
  - RST(Reset)：如果 RST 为 1 的时候，表示联机会被马上结束，而无需等待终止确认手续。这也就是说， 这是个强制结束的联机，且发送端已断线。
  - SYN(Synchronous)：若为 1，表示发送端希望双方建立同步处理， 也就是要求建立联机。通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。
  - FIN(Finish)：若为 1 ，表示传送结束，所以通知对方数据传毕， 是否同意断线，只是发送者还在等待对方的响应而已。

  其实每个项目都很重要，不过我们这里仅对 ACK/SYN 有兴趣而已，这样未来在谈到防火墙的时候，你才会比较清楚为啥每个 TCP 封包都有所谓的『状态』条件！那就是因为联机方向的不同所致啊！底下我们会进一步讨论喔！ 至于其他的数据，就得请您自行查询网络相关书籍了！

- Window (滑动窗口)
  主要是用来控制封包的流量的，可以告知对方目前本身有的缓冲器容量(Receive Buffer) 还可以接收封包。当 Window=0 时，代表缓冲器已经额满，所以应该要暂停传输数据。 Window 的单位是 byte。

- Checksum(确认检查码)
  当数据要由发送端送出前，会进行一个检验的动作，并将该动作的检验值标注在这个字段上； 而接收者收到这个封包之后，会再次的对封包进行验证，并且比对原发送的 Checksum 值是否相符，如果相符就接受，若不符就会假设该封包已经损毁，进而要求对方重新发送此封包！

- Urgent Pointer(紧急资料)
  这个字段是在 Code 字段内的 URG = 1 时才会产生作用。可以告知紧急数据所在的位置。

- Options(任意资料)
  目前此字段仅应用于表示接收端可以接收的最大数据区段容量，若此字段不使用， 表示可以使用任意资料区段的大小。这个字段较少使用。

- Padding(补足字段)
  如同 IP 封包需要有固定的 32bits 表头一样， Options 由于字段为非固定， 所以也需要 Padding 字段来加以补齐才行。同样也是 32 bits 的整数。

> ### TCP 的三向交握

TCP 被称为可靠的联机封包，主要是透过许多机制来达成的，其中最重要的就是三向交握的功能。

![](..\images\3_hand_shak.png)

在上面的封包连接模式当中，在建立联机之前都必须要通过三个确认的动作， 所以这种联机方式也就被称为三向交握(Three-way handshake)。 那么我们将整个流程依据上面的 A, B, C, D 四个阶段来说明一下：

- A:封包发起
  当客户端想要对服务器端联机时，就必须要送出一个要求联机的封包，此时客户端必须随机取用一个大于 1024 以上的端口来做为程序沟通的接口。然后在 TCP 的表头当中，必须要带有 SYN 的主动联机(SYN=1)，并且记下发送出联机封包给服务器端的序号 (Sequence number = 10001) 。
- B:封包接收与确认封包传送
  当服务器接到这个封包，并且确定要接收这个封包后，就会开始制作一个同时带有 SYN=1, ACK=1 的封包， 其中那个 acknowledge 的号码是要给 client 端确认用的，所以该数字会比(A 步骤)里面的 Sequence 号码多一号 (ack = 10001+1 = 10002)， 那我们服务器也必须要确认客户端确实可以接收我们的封包才行，所以也会发送出一个 Sequence (seq=20001) 给客户端，并且开始等待客户端给我们服务器端的回应喔！
- C:回送确认封包
  当客户端收到来自服务器端的 ACK 数字后 (10002) 就能够确认之前那个要求封包被正确的收受了， 接下来如果客户端也同意与服务器端建立联机时，就会再次的发送一个确认封包 (ACK=1) 给服务器，亦即是 acknowledge = 20001+1 = 20002 啰。
- D:取得最后确认
  若一切都顺利，在服务器端收到带有 ACK=1 且 ack=20002 序号的封包后，就能够建立起这次的联机了。

> ## **非连接导向的 UDP 协议**

UDP 的全名是：『User Datagram Protocol, 用户数据流协议』，UDP 与 TCP 不一样， UDP 不提供可靠的传输模式，因为他不是面向连接的一个机制，这是因为在 UDP 的传送过程中，接受端在接受到封包之后，不会回复响应封包 (ACK) 给发送端，所以封包并没有像 TCP 封包有较为严密的检查机制。至于 UDP 的表头资料如下表所示：

![image-20210115173434850](..\images\image-20210115173434850.png)

​																				UDP 封包的表头资料

UDP 封包由于不需要确认对方是否有正确的收到数据，故表头数据较少，所以 UDP 就可以在 Data 处填入更多的资料了。同时 UDP 比较适合需要实时反应的一些数据流，例如影像实时传送软件等， 就可以使用这类的封包传送。也就是说， UDP 传输协议并不考虑联机要求、联机终止与流量控制等特性， 所以使用的时机是当数据的正确性不很重要的情况，例如网络摄影机！

很多的软件其实是同时提供 TCP 与 UDP 的传输协议的，举例来说，查询主机名的 DNS 服务就同时提供了 UDP/TCP 协议。由于 UDP 较为快速，所以我们 client 端可以先使用 UDP 来与服务器联机。 但是当使用 UDP 联机却还是无法取得正确的数据时，便转换为较为可靠的 TCP 传输协议来进行数据的传输啰。 这样可以同时兼顾快速与可靠的传输！

> ## 通讯端口（port）

在 TCP 表头数据中，最重要的就属那 16 位的两个来源与目标的端口。由于是 16 位，因此目标与来源端口最大可达 65535 号 (2 的 16 次方)！ 网络是双向的，服务器与客户端要达成联机的话， 两边应该要有一个对应的端口来达成联机信道，好让数据可以透过这个信道来进行沟通。IP 是门牌，TCP 是楼层，真正提供服务的， 是在该楼层的那个人 (程序)！

+ **特权端口(Privileged Ports)**

  Internet 上面已经有很多规范好的固定 port (well-known port)， 这些 port number 通常小于 1024 ，且是提供给许多知名的网络服务软件用的。 在我们的 Linux 环境下，各网络服务与 port number 的对应默认给他写在 /etc/services 档案内。

  | 端口 | 服务名称与内容                                      |
  | ---- | --------------------------------------------------- |
  | 20   | FTP-data，文件传输协议所使用的主动数据传输端口      |
  | 21   | FTP，文件传输协议的命令通道                         |
  | 22   | SSH，较为安全的远程联机服务器                       |
  | 23   | Telnet，早期的远程联机服务器软件                    |
  | 25   | SMTP，简单邮件传递协议，用在作为 mail server 的端口 |
  | 53   | DNS，用在作为名称解析的领域名服务器                 |
  | 80   | WWW，这个重要吧！就是全球信息网服务器               |
  | 110  | POP3，邮件收信协议，办公室用的收信软件都是透过他    |
  | 443  | https，有安全加密机制的WWW服务器                    |

注意：小于 1024 以下的埠口要启动时， 启动者的身份必须要是 root 才行，所以才叫做特权端口。

+ **Socket Pair**

  由于网络是双向的，要达成联机的话得要服务器与客户端均提供了 IP 与埠口才行。 因此，我们常常将这个成对的数据称之为 Socket Pair 了！

  + 来源 IP + 来源埠口 (Source Address + Source Port)
  + 目的 IP + 目的埠口 (Destination Address + Destination Port)     

  由于 IP 与埠口常常连在一起说明，因此网络寻址常常使用『 IP:port 』来说明



> ##  **网络防火墙与 OSI 七层协定**

数据的传送其实就是封包的发出与接受的动作啦！并且不同的封包上面都有不一样的表头 (header)，此外，封包上面通常都会具有四个基本的信息，那就是 socket pair 里面提到的『来源与目的 IP 以及来源与目的端的 port number』 。当然啦，如果是可靠性联机的 TCP 封包，还包含 Control Flag 里面的 SYN/ACK 等等重要的信息。

封包过滤式的网络防火墙可以抵挡掉一些可能有问题的封包， Linux 系统上面是怎么挡掉封包的呢？其实说来也是很简单，既然封包的表头上面已经有这么多的重要信息， 那么我就利用一些防火墙机制与软件来进行封包表头的分析，并且设定分析的规则，当发现某些特定的 IP 、特定的埠口或者是特定的封包信息(SYN/ACK等等)，那么就将该封包给他丢弃， 那就是最基本的防火墙原理了！

Telnet（远程登录） 这个服务器是挺危险的，而 Telnet 使用的 port number 为 23 ，所以，当我们使用软件去分析要送进我们主机的封包时， 只要发现该封包的目的地是我们主机的 port 23 ，就将该封包丢掉去！那就是最基本的防火墙案例啦！ 如果以 OSI 七层协议来说，每一层可以抵挡的数据有：

- 第二层：可以针对来源与目标的 MAC 进行抵挡；（数据链结层）
- 第三层：主要针对来源与目标的 IP ，以及 ICMP 的类别 (type) 进行抵挡；（网络层）
- 第四层：针对 TCP/UDP 的埠口进行抵挡，也可以针对 TCP 的状态 (code) 来处理。（传输层）